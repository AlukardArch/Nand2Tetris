// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/1/And.hdl
/**
 * And gate:
 * if (a and b) out = 1, else out = 0 
 */
CHIP CPU {

    IN  inM[16],         // M value input  (M = contents of RAM[A])
        instruction[16], // Instruction for execution
        reset;           // Signals whether to re-start the current
                         // program (reset==1) or continue executing
                         // the current program (reset==0).

    OUT outM[16],        // M value output
        writeM,          // Write to M? 
        addressM[15],    // Address in data memory (of M)
        pc[15];          // address of next instruction

    PARTS:
   //intruction handling///////////////////////
   //A or C instruction type decided by Op code instruction last bit [15]
   Not(in=instruction[15] , out=notIns );
   Mux16(a=ALUout , b=instruction , sel=notIns , out=aorcinstruction );
   //ARegister load decided by 1 [3] or 3rd [5] destination bit of instruction for now set as 3rd [5]
   Or(a=notIns , b=instruction[5] , out=loadRA );
   ARegister(in=aorcinstruction , load=loadRA , out=ARegout, out[0..14]=addressM );
   //////////////////////////////////////////////////////////////////////////////

   ///ALU operation///////////////////////////////////////////////////////////////////////////
   //ALU Data inputs//

   //Mux that decide between A register and M register (inM) contrled by a bit of instruction [12]
   And(a=instruction[15] , b=instruction[12] , out=loadMorA );
   Mux16(a=ARegout , b=inM , sel=loadMorA , out=ARegorMReg );

   //DReg controlled by middle destination bit [4] if load value of ALU out or not
   And(a=instruction[15] , b=instruction[4] , out=loadD );
   DRegister(in=ALUout , load=loadD , out=DRegout );

   //ALU x=DRegout y=ARegorMReg| controll bits defined by instruction as follows
   // zx = [11] nx = [10] zy = [9] ny = [8] f = [7] no = [6] |if error maybe reversed
   ALU(x=DRegout , y=ARegorMReg , zx=instruction[11] , nx=instruction[10] , zy=instruction[9] , ny=instruction[8] , f=instruction[7] , no=instruction[6] , out=outM, out=ALUout , zr=zrr , ng=ngg );

   And(a=instruction[15] , b=instruction[3] , out=writeM );
   ///////////////////////////////////////////////////////////////////////////////////////

     //////////////////Jump condition calculated//////////////////////////////
    Not(in=zrr , out=notzrr );
    Not(in=ngg , out=notngg );
    
    //equal 0
    And(a=zrr , b=instruction[1] , out=JEQ );
    //negative
    And(a=ngg , b=instruction[2] , out=JLT );
    //zero or neg
    Or(a=zrr , b=ngg , out=JGE );
    //positive
    Not(in=JGE , out=positive );
    And(a=positive , b=instruction[0] , out=JGT );

    Or(a=JEQ , b=JLT , out=JLE );
    Or(a=JLE , b=JGT , out=jumpout );

    And(a=instruction[15] , b=jumpout , out=baGNO );

    Not(in=baGNO , out=notbaGNO );

   //if load = 1 than PC=A else PC++
   PC(in=ARegout , load=baGNO , inc=notbaGNO , reset=reset , out[0..14]=pc );
}   
